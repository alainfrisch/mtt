(*
(* Flattening *)

expr FlattenAux =
  if Copy in Atom then (Copy,accu)
  else let accu = >FlattenAux in <FlattenAux

expr Flatten =
  let accu = 0 in FlattenAux

check Flatten: (1,2) -> (1,(2,(3,0)))

(* check Flatten : ((1,2),Empty) -> (1,(2,(Atom,0)) *)

type Seq = (Atom,Seq) | 0
type SeqOne = (1,SeqOne) | 0
type OnlyOne = (OnlyOne,OnlyOne) | 1

check Flatten : OnlyOne -> SeqOne

(*
expr SetLeftMost = if Copy in Atom then x else (<SetLeftMost, >Copy)

infer (let x = Copy in SetLeftMost) in ((5,Atom),Atom)
*)

*)

expr FlattenAux =
  if Copy in () then accu else 
  let accu = >FlattenAux in
  let accu = <FlattenAux in
  _[], accu

expr Flatten =
  let accu = () in FlattenAux

(*eval Flatten  a[b[]],c[d[]] *)
check Flatten : a[b[]],b[] -> a[],b[]