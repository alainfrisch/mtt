/* Flattening */

expr FlattenAux =
  if Copy in Atom then (Copy,accu)
  else let accu = >FlattenAux in <FlattenAux

expr Flatten =
  let accu = 0 in FlattenAux

/* infer Flatten in (1,(2,(3,0))) */

type Seq = (Atom,Seq) | 0
type SeqOne = (1,SeqOne) | 0
type OnlyOne = (OnlyOne,OnlyOne) | 1 | 2

check Flatten : OnlyOne -> SeqOne

/*
expr SetLeftMost = if Copy in Atom then x else (<SetLeftMost, >Copy)

infer (let x = Copy in SetLeftMost) in ((5,Atom),Atom)
*/